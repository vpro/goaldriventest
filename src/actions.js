// Copyright (c) VPRO
// Licensed under the MIT license.
// Author: Mathijn Elhorst.
//
// This file contains the logic for the "actions" that the AI can take.

"use strict";

// The class Action is the abstract base class for all actions
class Action {
  constructor(actionType) {
    this.actionType = actionType;
  }

  /**
   * The function that is called by the AI to perform the actual action in the browser
   * @param {*} page - the page to perform the action on
   * @param {*} actionPayload - the action payload in json that was generated by the AI
   */
  async perform(page, actionPayload) {
    throw new Error("Perform method must be implemented by subclasses");
  }

  /**
   * The function that is called to describe the action and its json format to the AI.
   * This will added to the prompt that is sent to the AI.
   */
  getPromptInfo() {
    throw new Error("getPromptInfo method must be implemented by subclasses");
  }

  /**
   * Function is called when generating the HTML report to display the action that was taken
   * @param {*} actionPayload - the action payload in json that was generated by the AI
   */
  getDescriptionHTML(actionPayload) {
    throw new Error(
      "getDescriptionHTML method must be implemented by subclasses",
    );
  }

  // Helper functions
  /**
   * Function to get the element info (x,y,width,height) from the elementNumber in actionPayload
   * NOTE: This is a temporary solution until OpenAI can give back accurate x, y information of elements itself
   * @param {*} page - the page to perform the action on
   * @param {*} actionPayload - the action payload in json that was generated by the AI
   * @returns element info from the elementNumber in actionPayload or undefined if invalid elementNumber is given
   */
  async getElementInfo(page, actionPayload) {
    if (actionPayload.elementNumber === undefined) {
      return undefined;
    }

    const elements = JSON.parse(
      await page.evaluate(() =>
        JSON.stringify(window.goal_driven_test_element_info),
      ),
    );
    if (
      elements === undefined ||
      actionPayload.elementNumber < 0 ||
      actionPayload.elementNumber >= elements.length
    ) {
      return undefined;
    }

    return elements[actionPayload.elementNumber];
  }

  /**
   * Function to determine the x,y position to use in the action
   * @param {*} page - the page to perform the action on
   * @param {*} actionPayload - the action payload in json that was generated by the AI
   * @returns {x,y} position to use in the action or undefined if no elementNumber is given and no x,y is given in actionPayload
   */
  async getXY(page, actionPayload) {
    const element = await this.getElementInfo(page, actionPayload);
    if (element === undefined) {
      // fallback to x and y
      if (actionPayload.x === undefined || actionPayload.y === undefined) {
        return undefined;
      }

      return { x: actionPayload.x, y: actionPayload.y };
    }

    return {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2,
    };
  }
}

/**
 * Below are the actual actions that the AI can take
 *
 */

const MOVE_STEPS = { steps: 10 };

/**
 * The ClickAction class is the action that is performed when the AI wants to click on an element
 */
class ClickAction extends Action {
  constructor() {
    super("click");
  }

  async perform(page, actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    const xy = await this.getXY(page, actionPayload);
    const info = `Clicking at ${xy?.x}, ${xy?.y}`;
    if (xy !== undefined) {
      await page.mouse.move(xy.x, xy.y, MOVE_STEPS);  // first move to the element
      await page.mouse.click(xy.x, xy.y);
    }

    return info;
  }

  getPromptInfo() {
    return `To click on a element use the following action structure:
        1. "actionType": "click" (required)
        2. "elementNumber": The number of the element that is to be acted upon. The number can be found in the yellow box just above that element.  (required)`;
  }

  getDescriptionHTML(actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">üëÜ ${actionPayload.actionType}</span>
             <p><b>Element Number:</b> <span id="elementNumber">${actionPayload.elementNumber}</span></p>`;
  }
}

/**
 * The ScrollAction class is the action that is performed when the AI wants to scroll on an element or the page
 */
class ScrollAction extends Action {
  constructor() {
    super("scroll");
  }

  async perform(page, actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    let xy = await this.getXY(page, actionPayload);
    if (xy === undefined) {
      // for the moment go to the middle of the page
      const size = await page.evaluate(() => ({
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
      }));

      xy = { x: size.width / 2, y: size.height / 2 };
    }
    await page.mouse.move(xy.x, xy.y, MOVE_STEPS);

    let distanceX;
    let distanceY;
    if ("distance" in actionPayload) {
      const viewport = await page.viewport();
      if (actionPayload.distance == "little") {
        distanceX = viewport.width / 4;
        distanceY = viewport.height / 4;
      } else if (actionPayload.distance == "medium") {
        distanceX = viewport.width / 2;
        distanceY = viewport.height / 2;
      } else if (actionPayload.distance == "far") {
        distanceX = viewport.width;
        distanceY = viewport.height;
      } else {
        throw new Error(
          "distance value little, medium or far should be given in scroll action",
        );
      }
    } else {
      throw new Error("distance should be given in scroll action");
    }

    let deltaX = 0;
    let deltaY = 0;
    if ("direction" in actionPayload) {
      if (actionPayload.direction == "up") {
        deltaY = -parseInt(distanceY);
      } else if (actionPayload.direction == "down") {
        deltaY = parseInt(distanceY);
      } else if (actionPayload.direction == "left") {
        deltaX = -parseInt(distanceX);
      } else if (actionPayload.direction == "right") {
        deltaX = parseInt(distanceX);
      } else {
        throw new Error(
          "Direction value up, down, left or right should be given in scroll action",
        );
      }
    } else {
      throw new Error("direction should be given in scroll action");
    }

    const info = `Scrolling deltaX: ${deltaX}, deltaY: ${deltaY} on mouse position ${xy.x}, ${xy.y}`;
    await page.mouse.wheel({ deltaX, deltaY });

    return info;
  }

  getPromptInfo() {
    return `To scroll the page or inside an element use the following action structure:
        1. "actionType": "scroll" (required)
        2. "elementNumber": The number of the element or -1 to scroll the page (required)
        3. "direction": either "up", "down", "left", "right" (required)
        4. "distance": either "little" (25% page), "medium" (50% page)  or "far" (100% page) (required)
        To determine if the distance should be increased or decreased in possible next steps write something in the description to make that possible.`;
  }

  getDescriptionHTML(actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">üñ±Ô∏è ${actionPayload.actionType}</span>
            <p><b>Element Number:</b> <span id="elementNumber">${actionPayload.elementNumber}</span></p>
            <p><b>Distance:</b> <span id="distance">${actionPayload.distance}</span></p>
            <p><b>Direction:</b> <span id="direction">${actionPayload.direction}</span></p>`;
  }
}

/**
 * The NavigateAction class is the action that is performed when the AI wants to navigate to the previous or next page
 *
 */
class NavigateAction extends Action {
  constructor() {
    super("navigate");
  }

  async perform(page, actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    switch (actionPayload.direction) {
      case "back":
        await page.goBack();
        break;
      case "forward":
        await page.goForward();
        break;
      default:
        throw new Error("Invalid direction");
    }

    return `Navigate ${actionPayload.direction}`;
  }

  getPromptInfo() {
    return `To navigate to the previous or next page use the following action structure:
        1. "actionType": "navigate" (required)
        2. "direction": Either "back" or "forward" (required)`;
  }

  getDescriptionHTML(actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">‚ÜîÔ∏è ${actionPayload.actionType} ${actionPayload.direction}</span>`;
  }
}

/**
 * The InputAction class is the action that is performed when the AI wants to input text
 */
class InputAction extends Action {
  constructor() {
    super("input");
  }

  async perform(page, actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    if (!actionPayload.text) {
      throw new Error("No text given");
    }

    await page.keyboard.type(actionPayload.text);

    return `Add text ${actionPayload.text}`;
  }

  getPromptInfo() {
    return `To fill in text on focused element (by clicking first) use the following action structure:
        1. "actionType": "input" (required)
        3. "text": The text to input (required)`;
  }

  getDescriptionHTML(actionPayload) {
    if (actionPayload.actionType !== this.actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">üî† ${actionPayload.actionType}</span>`;
  }
}

/**
 * The actions object contains all the actions that the AI can take
 */

const actions = {
  click: new ClickAction(),
  scroll: new ScrollAction(),
  navigate: new NavigateAction(),
  input: new InputAction(),
};

export { actions };
