// Copyright (c) VPRO
// Licensed under the MIT license.
// Author: Mathijn Elhorst.
//
// This file contains the logic for the "actions" that the AI can take.

"use strict";

import { Page } from "puppeteer";

export interface ActionPayload {
  actionType: string;
  elementNumber?: number;
  x?: number;
  y?: number;
  direction?: string;
  distance?: string;
  text?: string;
}

// The class Action is the abstract base class for all actions
export class Action {
  protected _actionType: string;

  constructor(actionType: string) {
    this._actionType = actionType;
  }

  getActionType(): string {
    return this._actionType;
  }

  /**
   * The function that is called by the AI to perform the actual action in the browser. A text string is returned that describes the taken action.
   */
  async perform(page: Page, actionPayload: ActionPayload): Promise<string> {
    throw new Error("Perform method must be implemented by subclasses");
  }

  /**
   * The function that is called to describe the action and its json format to the AI.
   * This will added to the prompt that is sent to the AI.
   */
  getPromptInfo(): string {
    throw new Error("getPromptInfo method must be implemented by subclasses");
  }

  /**
   * Function is called when generating the HTML report to display the action that was taken
   */
  getDescriptionHTML(actionPayload: ActionPayload): string {
    throw new Error(
      "getDescriptionHTML method must be implemented by subclasses",
    );
  }

  // Helper functions
  /**
   * Function to get the element info (x,y,width,height) from the elementNumber in actionPayload
   * NOTE: This is a temporary solution until OpenAI can give back accurate x, y information of elements itself
   * @param {*} page - the page to perform the action on
   * @param {*} actionPayload - the action payload in json that was generated by the AI
   * @returns element info from the elementNumber in actionPayload or undefined if invalid elementNumber is given
   */
  async getElementInfo(
    page: Page,
    actionPayload: ActionPayload,
  ): Promise<number | undefined> {
    if (actionPayload.elementNumber === undefined) {
      return undefined;
    }

    const elements = JSON.parse(
      await page.evaluate(() =>
        JSON.stringify((window as any).goal_driven_test_element_info),
      ),
    );
    if (
      elements === undefined ||
      actionPayload.elementNumber < 0 ||
      actionPayload.elementNumber >= elements.length
    ) {
      return undefined;
    }

    return elements[actionPayload.elementNumber];
  }

  /**
   * Function to determine the x,y position to use in the action
   */
  async getXY(page: Page, actionPayload: ActionPayload) {
    const element: any = await this.getElementInfo(page, actionPayload);
    if (element === undefined) {
      // fallback to x and y
      if (actionPayload.x === undefined || actionPayload.y === undefined) {
        return undefined;
      }

      return { x: actionPayload.x, y: actionPayload.y };
    }

    return {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2,
    };
  }
}

/**
 * Below are the actual actions that the AI can take
 *
 */

const MOVE_STEPS = { steps: 10 };

/**
 * The ClickAction class is the action that is performed when the AI wants to click on an element
 */
class ClickAction extends Action {
  constructor() {
    super("click");
  }

  async perform(page: Page, actionPayload: ActionPayload): Promise<string> {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    const xy = await this.getXY(page, actionPayload);
    const info = `Clicking at ${xy?.x}, ${xy?.y}`;
    if (xy !== undefined) {
      await page.mouse.move(xy.x, xy.y, MOVE_STEPS); // first move to the element
      await page.mouse.click(xy.x, xy.y);
    }

    return info;
  }

  getPromptInfo(): string {
    return `To click on a element use the following action structure:
        1. "actionType": "click" (required)
        2. "elementNumber": The number of the element that is to be acted upon. The number can be found in the yellow box just above that element.  (required)`;
  }

  getDescriptionHTML(actionPayload: ActionPayload): string {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">üëÜ ${actionPayload.actionType}</span>
             <p><b>Element Number:</b> <span id="elementNumber">${actionPayload.elementNumber}</span></p>`;
  }
}

/**
 * The ScrollAction class is the action that is performed when the AI wants to scroll on an element or the page
 */

const SCROLL_DIVIDER = {
  little: 4,
  medium: 2,
  far: 1,
};

class ScrollAction extends Action {
  constructor() {
    super("scroll");
  }

  async perform(page: Page, actionPayload: ActionPayload): Promise<string> {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    let xy = await this.getXY(page, actionPayload);
    if (xy === undefined) {
      // for the moment go to the middle of the page
      const size = await page.evaluate(() => ({
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
      }));

      xy = { x: size.width / 2, y: size.height / 2 };
    }
    await page.mouse.move(xy.x, xy.y, MOVE_STEPS);

    let distanceX: number;
    let distanceY: number;
    if ("distance" in actionPayload) {
      const divider = SCROLL_DIVIDER[actionPayload.distance as keyof typeof SCROLL_DIVIDER];
      if (divider === undefined) {
        throw new Error(
          "distance value little, medium or far should be given in scroll action",
        );
      }
      const viewport = page.viewport();
      if (viewport === null) {
        throw new Error("Viewport not found in scroll action");
      }
      distanceX = Math.round(viewport.width / divider);
      distanceY = Math.round(viewport.height / divider);
    } else {
      throw new Error("distance should be given in scroll action");
    }

    let deltaX = 0;
    let deltaY = 0;
    if ("direction" in actionPayload) {
      if (actionPayload.direction == "up") {
        deltaY = -distanceY;
      } else if (actionPayload.direction == "down") {
        deltaY = distanceY;
      } else if (actionPayload.direction == "left") {
        deltaX = -distanceX;
      } else if (actionPayload.direction == "right") {
        deltaX = distanceX;
      } else {
        throw new Error(
          "Direction value up, down, left or right should be given in scroll action",
        );
      }
    } else {
      throw new Error("direction should be given in scroll action");
    }

    const info = `Scrolling deltaX: ${deltaX}, deltaY: ${deltaY} on mouse position ${xy.x}, ${xy.y}`;
    await page.mouse.wheel({ deltaX, deltaY });

    return info;
  }

  getPromptInfo(): string {
    return `To scroll the page or inside an element use the following action structure:
        1. "actionType": "scroll" (required)
        2. "elementNumber": The number of the element or -1 to scroll the page (required)
        3. "direction": either "up", "down", "left", "right" (required)
        4. "distance": either "little" (25% page), "medium" (50% page)  or "far" (100% page) (required)
        To determine if the distance should be increased or decreased in possible next steps write something in the description to make that possible.`;
  }

  getDescriptionHTML(actionPayload: ActionPayload): string {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">üñ±Ô∏è ${actionPayload.actionType}</span>
            <p><b>Element Number:</b> <span id="elementNumber">${actionPayload.elementNumber}</span></p>
            <p><b>Distance:</b> <span id="distance">${actionPayload.distance}</span></p>
            <p><b>Direction:</b> <span id="direction">${actionPayload.direction}</span></p>`;
  }
}

/**
 * The NavigateAction class is the action that is performed when the AI wants to navigate to the previous or next page
 *
 */
class NavigateAction extends Action {
  constructor() {
    super("navigate");
  }

  async perform(page: Page, actionPayload: ActionPayload): Promise<string> {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    switch (actionPayload.direction) {
      case "back":
        await page.goBack();
        break;
      case "forward":
        await page.goForward();
        break;
      default:
        throw new Error("Invalid direction");
    }

    return `Navigate ${actionPayload.direction}`;
  }

  getPromptInfo(): string {
    return `To navigate to the previous or next page use the following action structure:
        1. "actionType": "navigate" (required)
        2. "direction": Either "back" or "forward" (required)`;
  }

  getDescriptionHTML(actionPayload: ActionPayload): string {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">‚ÜîÔ∏è ${actionPayload.actionType} ${actionPayload.direction}</span>`;
  }
}

/**
 * The InputAction class is the action that is performed when the AI wants to input text
 */
class InputAction extends Action {
  constructor() {
    super("input");
  }

  async perform(page: Page, actionPayload: ActionPayload): Promise<string> {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    if (!actionPayload.text) {
      throw new Error("No text given");
    }

    await page.keyboard.type(actionPayload.text);

    return `Add text ${actionPayload.text}`;
  }

  getPromptInfo(): string {
    return `To fill in text on focused element (by clicking first) use the following action structure:
        1. "actionType": "input" (required)
        3. "text": The text to input (required)`;
  }

  getDescriptionHTML(actionPayload: ActionPayload): string {
    if (actionPayload.actionType !== this._actionType) {
      throw new Error("Action type does not match");
    }

    return `
            <span id="action-icon">üî† ${actionPayload.actionType}</span>`;
  }
}

/**
 * The actions object contains all the actions that the AI can take
 */
class ActionFactory {
  private _actions: Action[] = [];

  registerAction(action: Action): void {
    if (this.getAction(action.getActionType()) !== undefined) {
      throw new Error(`Action ${action.getActionType()} already registered`);
    }
    this._actions.push(action);
  }

  getAction(actionType: string): Action | undefined {
    return this._actions.find(
      (action) => action.getActionType() === actionType,
    );
  }

  getAllActions(): Action[] {
    return this._actions;
  }
}

export const actionFactoryInstance = new ActionFactory();
actionFactoryInstance.registerAction(new ClickAction());
actionFactoryInstance.registerAction(new ScrollAction());
actionFactoryInstance.registerAction(new NavigateAction());
actionFactoryInstance.registerAction(new InputAction());
